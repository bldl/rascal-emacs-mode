(defvar rascal-prelude-candidates '(
    ("AccessDenied" "function AccessDenied : RuntimeException (loc) in Exception")
    ("AssertionFailed" "function AssertionFailed : RuntimeException () in Exception; OR\nfunction AssertionFailed : RuntimeException (str) in Exception")
    ("Associativity" "data Associativity in ParseTree = right() | non-assoc() | left() | assoc()")
    ("Attr" "data Attr in ParseTree = bracket() | tag(value) | assoc(Associativity); OR\ndata Attr in Type = tag(value)")
    ("CharRange" "data CharRange in ParseTree = range(int, int)")
    ("Condition" "data Condition in ParseTree = except(str) | not-precede(Symbol) | not-follow(Symbol) | at-column(int) | delete(Symbol) | precede(Symbol) | follow(Symbol) | end-of-line() | begin-of-line()")
    ("Duration" "data Duration in DateTime = duration(int, int, int, int, int, int, int)")
    ("EmptyList" "function EmptyList : RuntimeException () in Exception")
    ("EmptyMap" "function EmptyMap : RuntimeException () in Exception")
    ("EmptySet" "function EmptySet : RuntimeException () in Exception")
    ("Exception" "data Exception in ParseTree = typeCastException(type[value], type[value]); OR\ndata Exception in Type = typeCastException(type[value], type[value])")
    ("FileNotFound" "function FileNotFound : RuntimeException (str) in Exception")
    ("HostNotFound" "function HostNotFound : RuntimeException (loc) in Exception")
    ("IO" "function IO : RuntimeException (str) in Exception")
    ("IllegalArgument" "function IllegalArgument : RuntimeException () in Exception; OR\nfunction IllegalArgument : RuntimeException (value) in Exception; OR\nfunction IllegalArgument : RuntimeException (value, str) in Exception")
    ("IllegalIdentifier" "function IllegalIdentifier : RuntimeException (str) in Exception")
    ("IndexOutOfBounds" "function IndexOutOfBounds : RuntimeException (int) in Exception")
    ("Interval" "function Interval : interval (datetime, datetime) in DateTime")
    ("Java" "function Java : RuntimeException (str) in Exception")
    ("MissingCase" "function MissingCase : RuntimeException (value) in Exception")
    ("ModuleNotFound" "function ModuleNotFound : RuntimeException (str) in Exception")
    ("NoSuchAnnotation" "function NoSuchAnnotation : RuntimeException (str) in Exception")
    ("NoSuchElement" "function NoSuchElement : RuntimeException (value) in Exception")
    ("NoSuchKey" "function NoSuchKey : RuntimeException (value) in Exception")
    ("ParseError" "function ParseError : RuntimeException (loc) in Exception")
    ("PathNotFound" "function PathNotFound : RuntimeException (loc) in Exception")
    ("PermissionDenied" "function PermissionDenied : RuntimeException () in Exception; OR\nfunction PermissionDenied : RuntimeException (str) in Exception")
    ("Production" "data Production in ParseTree = regular(Symbol) | reference(Symbol, str) | prod(Symbol, list[Symbol], set[Attr]) | choice(Symbol, set[Production]) | others(Symbol) | associativity(Symbol, Associativity, set[Production]) | func(Symbol, list[Symbol], set[Attr]) | cons(Symbol, list[Symbol], set[Attr]) | priority(Symbol, list[Production]); OR\ndata Production in Type = choice(Symbol, set[Production]) | func(Symbol, list[Symbol], set[Attr]) | cons(Symbol, list[Symbol], set[Attr])")
    ("RuntimeException" "data RuntimeException in Exception = PermissionDenied(str) | PermissionDenied() | EmptyMap() | EmptyList() | ModuleNotFound(str) | NoSuchKey(value) | FileNotFound(str) | Java(str) | HostNotFound(loc) | IndexOutOfBounds(int) | IllegalArgument(value, str) | AccessDenied(loc) | ParseError(loc) | Timeout() | IllegalArgument() | SchemeNotSupported(loc) | Subversion(str) | EmptySet() | AssertionFailed() | AssertionFailed(str) | IO(str) | PathNotFound(loc) | IllegalArgument(value) | MissingCase(value) | IllegalIdentifier(str) | NoSuchAnnotation(str) | NoSuchElement(value) | StackOverflow()")
    ("SchemeNotSupported" "function SchemeNotSupported : RuntimeException (loc) in Exception")
    ("StackOverflow" "function StackOverflow : RuntimeException () in Exception")
    ("Subversion" "function Subversion : RuntimeException (str) in Exception")
    ("Symbol" "data Symbol in ParseTree = node() | cilit(str) | str() | int() | lit(str) | parameterized-sort(str, list[Symbol]) | value() | empty() | char-class(list[CharRange]) | lex(str) | bag(Symbol) | rel(list[Symbol]) | set(Symbol) | reified(Symbol) | rat() | parameter(str, Symbol) | adt(str, list[Symbol]) | parameter(str) | opt(Symbol) | iter-star-seps(Symbol, list[Symbol]) | void() | func(Symbol, list[Symbol]) | alias(str, list[Symbol], Symbol) | iter-seps(Symbol, list[Symbol]) | cons(Symbol, list[Symbol]) | label(str, Symbol) | start(Symbol) | iter(Symbol) | keywords(str) | datetime() | seq(list[Symbol]) | list(Symbol) | map(Symbol, Symbol) | real() | layouts(str) | loc() | var-func(Symbol, list[Symbol], Symbol) | bool() | alt(set[Symbol]) | conditional(Symbol, set[Condition]) | tuple(list[Symbol]) | sort(str) | iter-star(Symbol) | num(); OR\ndata Symbol in Type = node() | str() | int() | value() | bag(Symbol) | rel(list[Symbol]) | set(Symbol) | reified(Symbol) | rat() | parameter(str, Symbol) | adt(str, list[Symbol]) | void() | func(Symbol, list[Symbol]) | alias(str, list[Symbol], Symbol) | cons(Symbol, list[Symbol]) | label(str, Symbol) | datetime() | list(Symbol) | map(Symbol, Symbol) | real() | loc() | var-func(Symbol, list[Symbol], Symbol) | bool() | tuple(list[Symbol]) | num()")
    ("Timeout" "function Timeout : RuntimeException () in Exception")
    ("Tree" "data Tree in ParseTree = cycle(Symbol, int) | appl(Production, list[Tree]) | erroramb(set[Tree]) | expected(Symbol) | error(Production, list[Tree], list[Tree]) | errorcycle(Symbol, int) | char(int) | amb(set[Tree])")
    ("TreeSearchResult" "data TreeSearchResult[&T<:Tree] in ParseTree = treeNotFound() | treeFound(&T)")
    ("adt" "function adt : Symbol (str, list[Symbol]) in ParseTree; OR\nfunction adt : Symbol (str, list[Symbol]) in Type")
    ("alias" "function alias : Symbol (str, list[Symbol], Symbol) in ParseTree; OR\nfunction alias : Symbol (str, list[Symbol], Symbol) in Type")
    ("alt" "function alt : Symbol (set[Symbol]) in ParseTree")
    ("amb" "function amb : Tree (set[Tree]) in ParseTree")
    ("appendToFile" "function appendToFile : void (loc, list[value]) in IO")
    ("appl" "function appl : Tree (Production, list[Tree]) in ParseTree")
    ("arbBool" "function arbBool : bool () in Boolean")
    ("arity" "function arity : int (node) in Node")
    ("assoc" "function assoc : Associativity () in ParseTree; OR\nfunction assoc : Attr (Associativity) in ParseTree")
    ("associativity" "function associativity : Production (Symbol, Associativity, set[Production]) in ParseTree; OR\nfunction associativity : Production (Symbol, Associativity, set[value]) in ParseTree")
    ("at-column" "function at-column : Condition (int) in ParseTree")
    ("bag" "function bag : Symbol (Symbol) in ParseTree; OR\nfunction bag : Symbol (Symbol) in Type")
    ("begin-of-line" "function begin-of-line : Condition () in ParseTree")
    ("bool" "function bool : Symbol () in ParseTree; OR\nfunction bool : Symbol () in Type")
    ("bottom" "function bottom : set[&T] (Graph[&T]) in Graph")
    ("bprintln" "function bprintln : bool (value) in IO")
    ("bracket" "function bracket : Attr () in ParseTree")
    ("capitalize" "function capitalize : str (str) in String")
    ("carrier" "function carrier : set[&T] (rel[&T, &T, &T, &T, &T]) in Relation; OR\nfunction carrier : set[&T] (rel[&T, &T, &T, &T]) in Relation; OR\nfunction carrier : set[&T] (rel[&T, &T, &T]) in Relation; OR\nfunction carrier : set[&T] (rel[&T, &T]) in Relation")
    ("carrierR" "function carrierR : rel[&T, &T, &T, &T, &T] (rel[&T, &T, &T, &T, &T], set[&T]) in Relation; OR\nfunction carrierR : rel[&T, &T, &T, &T] (rel[&T, &T, &T, &T], set[&T]) in Relation; OR\nfunction carrierR : rel[&T, &T, &T] (rel[&T, &T, &T], set[&T]) in Relation; OR\nfunction carrierR : rel[&T, &T] (rel[&T, &T], set[&T]) in Relation")
    ("carrierX" "function carrierX : rel[&T, &T, &T, &T, &T] (rel[&T, &T, &T, &T, &T], set[&T]) in Relation; OR\nfunction carrierX : rel[&T, &T, &T, &T] (rel[&T, &T, &T, &T], set[&T]) in Relation; OR\nfunction carrierX : rel[&T, &T, &T] (rel[&T, &T, &T], set[&T]) in Relation; OR\nfunction carrierX : rel[&T, &T] (rel[&T, &T], set[&T]) in Relation")
    ("center" "function center : str (str, int) in String; OR\nfunction center : str (str, int, str) in String")
    ("char" "function char : Tree (int) in ParseTree")
    ("char-class" "function char-class : Symbol (list[CharRange]) in ParseTree")
    ("charAt" "function charAt : int (str, int) in String")
    ("chars" "function chars : list[int] (str) in String")
    ("choice" "function choice : Production (Symbol, set[Production]) in ParseTree; OR\nfunction choice : Production (Symbol, set[Production]) in Type; OR\nfunction choice : Production (Symbol, set[value]) in ParseTree; OR\nfunction choice : Production (Symbol, set[value]) in Type")
    ("cilit" "function cilit : Symbol (str) in ParseTree")
    ("classify" "function classify : map[&K, set[&V]] (set[&V], &K (&V)) in Set")
    ("comparable" "function comparable : bool (Symbol, Symbol) in ParseTree; OR\nfunction comparable : bool (Symbol, Symbol) in Type")
    ("complement" "function complement : rel[&T0, &T1, &T2, &T3, &T4] (rel[&T0, &T1, &T2, &T3, &T4]) in Relation; OR\nfunction complement : rel[&T0, &T1, &T2, &T3] (rel[&T0, &T1, &T2, &T3]) in Relation; OR\nfunction complement : rel[&T0, &T1, &T2] (rel[&T0, &T1, &T2]) in Relation; OR\nfunction complement : rel[&T0, &T1] (rel[&T0, &T1]) in Relation")
    ("conditional" "function conditional : Symbol (Symbol, set[Condition]) in ParseTree")
    ("cons" "function cons : Production (Symbol, list[Symbol], set[Attr]) in ParseTree; OR\nfunction cons : Production (Symbol, list[Symbol], set[Attr]) in Type; OR\nfunction cons : Symbol (Symbol, list[Symbol]) in ParseTree; OR\nfunction cons : Symbol (Symbol, list[Symbol]) in Type")
    ("contains" "function contains : bool (str, str) in String")
    ("createDate" "function createDate : datetime (int, int, int) in DateTime")
    ("createDateTime" "function createDateTime : datetime (int, int, int, int, int, int, int) in DateTime; OR\nfunction createDateTime : datetime (int, int, int, int, int, int, int, int, int) in DateTime")
    ("createDuration" "function createDuration : Duration (datetime, datetime) in DateTime; OR\nfunction createDuration : Duration (interval) in DateTime")
    ("createInterval" "function createInterval : interval (datetime, datetime) in DateTime")
    ("createTime" "function createTime : datetime (int, int, int, int) in DateTime; OR\nfunction createTime : datetime (int, int, int, int, int, int) in DateTime")
    ("cycle" "function cycle : Tree (Symbol, int) in ParseTree")
    ("dateRangeByDay" "function dateRangeByDay : list[datetime] (interval) in DateTime")
    ("datetime" "function datetime : Symbol () in ParseTree; OR\nfunction datetime : Symbol () in Type")
    ("daysInInterval" "function daysInInterval : int (interval) in DateTime")
    ("decrementDays" "function decrementDays : datetime (datetime) in DateTime; OR\nfunction decrementDays : datetime (datetime, int) in DateTime")
    ("decrementHours" "function decrementHours : datetime (datetime) in DateTime; OR\nfunction decrementHours : datetime (datetime, int) in DateTime")
    ("decrementMilliseconds" "function decrementMilliseconds : datetime (datetime) in DateTime; OR\nfunction decrementMilliseconds : datetime (datetime, int) in DateTime")
    ("decrementMinutes" "function decrementMinutes : datetime (datetime) in DateTime; OR\nfunction decrementMinutes : datetime (datetime, int) in DateTime")
    ("decrementMonths" "function decrementMonths : datetime (datetime) in DateTime; OR\nfunction decrementMonths : datetime (datetime, int) in DateTime")
    ("decrementSeconds" "function decrementSeconds : datetime (datetime) in DateTime; OR\nfunction decrementSeconds : datetime (datetime, int) in DateTime")
    ("decrementYears" "function decrementYears : datetime (datetime) in DateTime; OR\nfunction decrementYears : datetime (datetime, int) in DateTime")
    ("delAnnotation" "function delAnnotation : &T<:node (&T<:node, str) in Node")
    ("delAnnotations" "function delAnnotations : &T<:node (&T<:node) in Node")
    ("delAnnotationsRec" "function delAnnotationsRec : &T (&T) in Node")
    ("delete" "function delete : Condition (Symbol) in ParseTree; OR\nfunction delete : list[&T] (list[&T], int) in List")
    ("distribution" "function distribution : map[&T element, int occurs] (list[&T]) in List; OR\nfunction distribution : map[&T element, int occurs] (map[&U event, &T bucket]) in Map; OR\nfunction distribution : map[&T element, int occurs] (rel[&U event, &T bucket]) in Relation")
    ("doc" "annotation doc : str for Tree in ParseTree")
    ("docs" "annotation docs : map[loc, str] for Tree in ParseTree")
    ("domain" "function domain : set[&K] (map[&K, &V]) in Map; OR\nfunction domain : set[&T0] (rel[&T0, &T1, &T2, &T3, &T4]) in Relation; OR\nfunction domain : set[&T0] (rel[&T0, &T1, &T2, &T3]) in Relation; OR\nfunction domain : set[&T0] (rel[&T0, &T1, &T2]) in Relation; OR\nfunction domain : set[&T0] (rel[&T0, &T1]) in Relation; OR\nfunction domain : set[int] (list[&T]) in List")
    ("domainR" "function domainR : map[&K, &V] (map[&K, &V], set[&K]) in Map; OR\nfunction domainR : rel[&T0, &T1, &T2, &T3, &T4] (rel[&T0, &T1, &T2, &T3, &T4], set[&T0]) in Relation; OR\nfunction domainR : rel[&T0, &T1, &T2, &T3] (rel[&T0, &T1, &T2, &T3], set[&T0]) in Relation; OR\nfunction domainR : rel[&T0, &T1, &T2] (rel[&T0, &T1, &T2], set[&T0]) in Relation; OR\nfunction domainR : rel[&T0, &T1] (rel[&T0, &T1], set[&T0]) in Relation")
    ("domainX" "function domainX : map[&K, &V] (map[&K, &V], set[&K]) in Map; OR\nfunction domainX : rel[&T0, &T1, &T2, &T3, &T4] (rel[&T0, &T1, &T2, &T3, &T4], set[&T0]) in Relation; OR\nfunction domainX : rel[&T0, &T1, &T2, &T3] (rel[&T0, &T1, &T2, &T3], set[&T0]) in Relation; OR\nfunction domainX : rel[&T0, &T1, &T2] (rel[&T0, &T1, &T2], set[&T0]) in Relation; OR\nfunction domainX : rel[&T0, &T1] (rel[&T0, &T1], set[&T0]) in Relation")
    ("drop" "function drop : list[&T] (int, list[&T]) in List")
    ("dup" "function dup : list[&T] (list[&T]) in List")
    ("duration" "function duration : Duration (int, int, int, int, int, int, int) in DateTime")
    ("empty" "function empty : Symbol () in ParseTree")
    ("end-of-line" "function end-of-line : Condition () in ParseTree")
    ("endsWith" "function endsWith : bool (str, str) in String")
    ("equivalent" "function equivalent : bool (Symbol, Symbol) in ParseTree; OR\nfunction equivalent : bool (Symbol, Symbol) in Type")
    ("error" "function error : Tree (Production, list[Tree], list[Tree]) in ParseTree")
    ("erroramb" "function erroramb : Tree (set[Tree]) in ParseTree")
    ("errorcycle" "function errorcycle : Tree (Symbol, int) in ParseTree")
    ("escape" "function escape : str (str, map[str, str]) in String")
    ("except" "function except : Condition (str) in ParseTree")
    ("exists" "function exists : bool (loc) in IO")
    ("expected" "function expected : Tree (Symbol) in ParseTree")
    ("find" "function find : loc (str, list[loc]) in IO")
    ("findAll" "function findAll : list[int] (str, str) in String")
    ("findFirst" "function findFirst : int (str, str) in String")
    ("findLast" "function findLast : int (str, str) in String")
    ("follow" "function follow : Condition (Symbol) in ParseTree")
    ("fromInt" "function fromInt : bool (int) in Boolean")
    ("fromString" "function fromString : bool (str) in Boolean")
    ("func" "function func : Production (Symbol, list[Symbol], set[Attr]) in ParseTree; OR\nfunction func : Production (Symbol, list[Symbol], set[Attr]) in Type; OR\nfunction func : Symbol (Symbol, list[Symbol]) in ParseTree; OR\nfunction func : Symbol (Symbol, list[Symbol]) in Type")
    ("getAnnotations" "function getAnnotations : map[str, value] (node) in Node")
    ("getChildren" "function getChildren : list[value] (node) in Node")
    ("getName" "function getName : str (node) in Node")
    ("getOneFrom" "function getOneFrom : &K (map[&K, &V]) in Map; OR\nfunction getOneFrom : &T (list[&T]) in List; OR\nfunction getOneFrom : &T (set[&T]) in Set")
    ("group" "function group : set[set[&T]] (set[&T], bool (&T, &T)) in Set")
    ("groupDomainByRange" "function groupDomainByRange : set[set[&U]] (rel[&U dom, &T ran]) in Relation")
    ("groupRangeByDomain" "function groupRangeByDomain : set[set[&T]] (rel[&U dom, &T ran]) in Relation")
    ("head" "function head : &T (list[&T]) in List; OR\nfunction head : list[&T] (list[&T], int) in List")
    ("headTail" "function headTail : tuple[&T,list[&T]] (list[&T]) in List")
    ("ident" "function ident : rel[&T, &T] (set[&T]) in Relation")
    ("implode" "function implode : &T<:node (type[&T<:node], Tree) in ParseTree")
    ("incrementDays" "function incrementDays : datetime (datetime) in DateTime; OR\nfunction incrementDays : datetime (datetime, int) in DateTime")
    ("incrementHours" "function incrementHours : datetime (datetime) in DateTime; OR\nfunction incrementHours : datetime (datetime, int) in DateTime")
    ("incrementMilliseconds" "function incrementMilliseconds : datetime (datetime) in DateTime; OR\nfunction incrementMilliseconds : datetime (datetime, int) in DateTime")
    ("incrementMinutes" "function incrementMinutes : datetime (datetime) in DateTime; OR\nfunction incrementMinutes : datetime (datetime, int) in DateTime")
    ("incrementMonths" "function incrementMonths : datetime (datetime) in DateTime; OR\nfunction incrementMonths : datetime (datetime, int) in DateTime")
    ("incrementSeconds" "function incrementSeconds : datetime (datetime) in DateTime; OR\nfunction incrementSeconds : datetime (datetime, int) in DateTime")
    ("incrementYears" "function incrementYears : datetime (datetime) in DateTime; OR\nfunction incrementYears : datetime (datetime, int) in DateTime")
    ("index" "function index : list[int] (list[&T]) in List; OR\nfunction index : map[&K, set[&V]] (rel[&K, &V]) in Relation; OR\nfunction index : map[&T element, int occurs] (set[&T]) in Set")
    ("indexOf" "function indexOf : int (list[&T], &T) in List")
    ("insertAt" "function insertAt : list[&T] (list[&T], int, &T) in List")
    ("int" "function int : Symbol () in ParseTree; OR\nfunction int : Symbol () in Type")
    ("intercalate" "function intercalate : str (str, list[value]) in List")
    ("interval" "data interval in DateTime = Interval(datetime, datetime)")
    ("invert" "function invert : map[&V, set[&K]] (map[&K, &V]) in Map; OR\nfunction invert : rel[&T1, &T0] (rel[&T0, &T1]) in Relation; OR\nfunction invert : rel[&T2, &T1, &T0] (rel[&T0, &T1, &T2]) in Relation; OR\nfunction invert : rel[&T3, &T2, &T1, &T0] (rel[&T0, &T1, &T2, &T3]) in Relation; OR\nfunction invert : rel[&T4, &T3, &T2, &T1, &T0] (rel[&T0, &T1, &T2, &T3, &T4]) in Relation")
    ("invertUnique" "function invertUnique : map[&V, &K] (map[&K, &V]) in Map")
    ("iprint" "function iprint : void (value) in IO")
    ("iprintExp" "function iprintExp : &T (&T) in IO")
    ("iprintln" "function iprintln : void (value) in IO")
    ("iprintlnExp" "function iprintlnExp : &T (&T) in IO")
    ("isADTType" "function isADTType : bool (Symbol) in ParseTree; OR\nfunction isADTType : bool (Symbol) in Type")
    ("isAliasType" "function isAliasType : bool (Symbol) in ParseTree; OR\nfunction isAliasType : bool (Symbol) in Type")
    ("isBagType" "function isBagType : bool (Symbol) in ParseTree; OR\nfunction isBagType : bool (Symbol) in Type")
    ("isBoolType" "function isBoolType : bool (Symbol) in ParseTree; OR\nfunction isBoolType : bool (Symbol) in Type")
    ("isConstructorType" "function isConstructorType : bool (Symbol) in ParseTree; OR\nfunction isConstructorType : bool (Symbol) in Type")
    ("isDateTimeType" "function isDateTimeType : bool (Symbol) in ParseTree; OR\nfunction isDateTimeType : bool (Symbol) in Type")
    ("isDirectory" "function isDirectory : bool (loc) in IO")
    ("isEmpty" "function isEmpty : bool (list[&T]) in List; OR\nfunction isEmpty : bool (map[&K, &V]) in Map; OR\nfunction isEmpty : bool (set[&T]) in Set; OR\nfunction isEmpty : bool (str) in String")
    ("isFile" "function isFile : bool (loc) in IO")
    ("isFunctionType" "function isFunctionType : bool (Symbol) in ParseTree; OR\nfunction isFunctionType : bool (Symbol) in Type")
    ("isIntType" "function isIntType : bool (Symbol) in ParseTree; OR\nfunction isIntType : bool (Symbol) in Type")
    ("isListType" "function isListType : bool (Symbol) in ParseTree; OR\nfunction isListType : bool (Symbol) in Type")
    ("isLocType" "function isLocType : bool (Symbol) in ParseTree; OR\nfunction isLocType : bool (Symbol) in Type")
    ("isMapType" "function isMapType : bool (Symbol) in ParseTree; OR\nfunction isMapType : bool (Symbol) in Type")
    ("isNodeType" "function isNodeType : bool (Symbol) in ParseTree; OR\nfunction isNodeType : bool (Symbol) in Type")
    ("isNumType" "function isNumType : bool (Symbol) in ParseTree; OR\nfunction isNumType : bool (Symbol) in Type")
    ("isRatType" "function isRatType : bool (Symbol) in ParseTree; OR\nfunction isRatType : bool (Symbol) in Type")
    ("isRealType" "function isRealType : bool (Symbol) in ParseTree; OR\nfunction isRealType : bool (Symbol) in Type")
    ("isReifiedType" "function isReifiedType : bool (Symbol) in ParseTree; OR\nfunction isReifiedType : bool (Symbol) in Type")
    ("isRelType" "function isRelType : bool (Symbol) in ParseTree; OR\nfunction isRelType : bool (Symbol) in Type")
    ("isSetType" "function isSetType : bool (Symbol) in ParseTree; OR\nfunction isSetType : bool (Symbol) in Type")
    ("isStrType" "function isStrType : bool (Symbol) in ParseTree; OR\nfunction isStrType : bool (Symbol) in Type")
    ("isTupleType" "function isTupleType : bool (Symbol) in ParseTree; OR\nfunction isTupleType : bool (Symbol) in Type")
    ("isTypeVar" "function isTypeVar : bool (Symbol) in ParseTree; OR\nfunction isTypeVar : bool (Symbol) in Type")
    ("isValidCharacter" "function isValidCharacter : bool (int) in String")
    ("isValueType" "function isValueType : bool (Symbol) in ParseTree; OR\nfunction isValueType : bool (Symbol) in Type")
    ("isVoidType" "function isVoidType : bool (Symbol) in ParseTree; OR\nfunction isVoidType : bool (Symbol) in Type")
    ("iter" "function iter : Symbol (Symbol) in ParseTree")
    ("iter-seps" "function iter-seps : Symbol (Symbol, list[Symbol]) in ParseTree")
    ("iter-star" "function iter-star : Symbol (Symbol) in ParseTree")
    ("iter-star-seps" "function iter-star-seps : Symbol (Symbol, list[Symbol]) in ParseTree")
    ("joinDateAndTime" "function joinDateAndTime : datetime (datetime, datetime) in DateTime")
    ("keywords" "function keywords : Symbol (str) in ParseTree")
    ("label" "function label : Symbol (str, Symbol) in ParseTree; OR\nfunction label : Symbol (str, Symbol) in Type")
    ("last" "function last : &T (list[&T]) in List")
    ("lastIndexOf" "function lastIndexOf : int (list[&T], &T) in List")
    ("lastModified" "function lastModified : datetime (loc) in IO")
    ("layouts" "function layouts : Symbol (str) in ParseTree")
    ("left" "function left : Associativity () in ParseTree; OR\nfunction left : str (str, int) in String; OR\nfunction left : str (str, int, str) in String")
    ("lex" "function lex : Symbol (str) in ParseTree")
    ("link" "annotation link : loc for Tree in ParseTree")
    ("links" "annotation links : set[loc] for Tree in ParseTree")
    ("list" "function list : Symbol (Symbol) in ParseTree; OR\nfunction list : Symbol (Symbol) in Type")
    ("listEntries" "function listEntries : list[str] (loc) in IO")
    ("lit" "function lit : Symbol (str) in ParseTree")
    ("loc" "annotation loc : loc for Tree in ParseTree; OR\nfunction loc : Symbol () in ParseTree; OR\nfunction loc : Symbol () in Type")
    ("lub" "function lub : Symbol (Symbol, Symbol) in ParseTree; OR\nfunction lub : Symbol (Symbol, Symbol) in Type; OR\nfunction lub : Symbol (Symbol, value) in ParseTree; OR\nfunction lub : Symbol (Symbol, value) in Type; OR\nfunction lub : list[Symbol] (list[Symbol], list[Symbol]) in ParseTree; OR\nfunction lub : list[Symbol] (list[Symbol], list[Symbol]) in Type")
    ("makeNode" "function makeNode : node (str, list[value]) in Node")
    ("map" "function map : Symbol (Symbol, Symbol) in ParseTree; OR\nfunction map : Symbol (Symbol, Symbol) in Type")
    ("mapper" "function mapper : list[&U] (list[&T], &U (&T)) in List; OR\nfunction mapper : map[&K, &V] (map[&K, &V], &L (&K), &W (&V)) in Map; OR\nfunction mapper : set[&U] (set[&T], &U (&T)) in Set")
    ("max" "function max : &T (list[&T]) in List; OR\nfunction max : &T (set[&T]) in Set")
    ("merge" "function merge : list[&T] (list[&T], list[&T]) in List; OR\nfunction merge : list[&T] (list[&T], list[&T], bool (&T, &T)) in List")
    ("message" "annotation message : Message for Tree in ParseTree")
    ("messages" "annotation messages : set[Message] for Tree in ParseTree")
    ("min" "function min : &T (list[&T]) in List; OR\nfunction min : &T (set[&T]) in Set")
    ("mix" "function mix : list[&T] (list[&T], list[&T]) in List")
    ("mkDirectory" "function mkDirectory : void (loc) in IO")
    ("node" "function node : Symbol () in ParseTree; OR\nfunction node : Symbol () in Type")
    ("non-assoc" "function non-assoc : Associativity () in ParseTree")
    ("not-follow" "function not-follow : Condition (Symbol) in ParseTree")
    ("not-precede" "function not-precede : Condition (Symbol) in ParseTree")
    ("now" "function now : datetime () in DateTime")
    ("num" "function num : Symbol () in ParseTree; OR\nfunction num : Symbol () in Type")
    ("opt" "function opt : Symbol (Symbol) in ParseTree")
    ("order" "function order : list[&T] (Graph[&T]) in Graph")
    ("others" "function others : Production (Symbol) in ParseTree")
    ("parameter" "function parameter : Symbol (str) in ParseTree; OR\nfunction parameter : Symbol (str, Symbol) in ParseTree; OR\nfunction parameter : Symbol (str, Symbol) in Type")
    ("parameterized-sort" "function parameterized-sort : Symbol (str, list[Symbol]) in ParseTree")
    ("parse" "function parse : &T<:Tree (type[&T<:Tree], loc) in ParseTree; OR\nfunction parse : &T<:Tree (type[&T<:Tree], map[Production robust, CharClass lookaheads], str, loc) in ParseTree; OR\nfunction parse : &T<:Tree (type[&T<:Tree], str) in ParseTree; OR\nfunction parse : &T<:Tree (type[&T<:Tree], str, loc) in ParseTree")
    ("parseDate" "function parseDate : datetime (str, str) in DateTime")
    ("parseDateInLocale" "function parseDateInLocale : datetime (str, str, str) in DateTime")
    ("parseDateTime" "function parseDateTime : datetime (str, str) in DateTime")
    ("parseDateTimeInLocale" "function parseDateTimeInLocale : datetime (str, str, str) in DateTime")
    ("parseTime" "function parseTime : datetime (str, str) in DateTime")
    ("parseTimeInLocale" "function parseTimeInLocale : datetime (str, str, str) in DateTime")
    ("permutations" "function permutations : set[list[&T]] (list[&T]) in List")
    ("pop" "function pop : tuple[&T,list[&T]] (list[&T]) in List")
    ("power" "function power : set[set[&T]] (set[&T]) in Set")
    ("power1" "function power1 : set[set[&T]] (set[&T]) in Set")
    ("precede" "function precede : Condition (Symbol) in ParseTree")
    ("predecessors" "function predecessors : set[&T] (Graph[&T], &T) in Graph")
    ("prefix" "function prefix : list[&T] (list[&T]) in List")
    ("print" "function print : void (value) in IO")
    ("printDate" "function printDate : str (datetime) in DateTime; OR\nfunction printDate : str (datetime, str) in DateTime")
    ("printDateInLocale" "function printDateInLocale : str (datetime, str) in DateTime; OR\nfunction printDateInLocale : str (datetime, str, str) in DateTime")
    ("printDateTime" "function printDateTime : str (datetime) in DateTime; OR\nfunction printDateTime : str (datetime, str) in DateTime")
    ("printDateTimeInLocale" "function printDateTimeInLocale : str (datetime, str) in DateTime; OR\nfunction printDateTimeInLocale : str (datetime, str, str) in DateTime")
    ("printExp" "function printExp : &T (&T) in IO; OR\nfunction printExp : &T (str, &T) in IO")
    ("printTime" "function printTime : str (datetime) in DateTime; OR\nfunction printTime : str (datetime, str) in DateTime")
    ("printTimeInLocale" "function printTimeInLocale : str (datetime, str) in DateTime; OR\nfunction printTimeInLocale : str (datetime, str, str) in DateTime")
    ("println" "function println : void () in IO; OR\nfunction println : void (value) in IO")
    ("printlnExp" "function printlnExp : &T (&T) in IO; OR\nfunction printlnExp : &T (str, &T) in IO")
    ("priority" "function priority : Production (Symbol, list[Production]) in ParseTree; OR\nfunction priority : Production (Symbol, list[value]) in ParseTree")
    ("prod" "function prod : Production (Symbol, list[Symbol], set[Attr]) in ParseTree")
    ("push" "function push : list[&T] (&T, list[&T]) in List")
    ("range" "function range : CharRange (int, int) in ParseTree; OR\nfunction range : rel[&T1, &T2, &T3, &T4] (rel[&T0, &T1, &T2, &T3, &T4]) in Relation; OR\nfunction range : rel[&T1, &T2, &T3] (rel[&T0, &T1, &T2, &T3]) in Relation; OR\nfunction range : rel[&T1, &T2] (rel[&T0, &T1, &T2]) in Relation; OR\nfunction range : set[&T1] (rel[&T0, &T1]) in Relation; OR\nfunction range : set[&V] (map[&K, &V]) in Map")
    ("rangeR" "function rangeR : map[&K, &V] (map[&K, &V], set[&V]) in Map; OR\nfunction rangeR : rel[&T0, &T1] (rel[&T0, &T1], set[&T2]) in Relation")
    ("rangeX" "function rangeX : map[&K, &V] (map[&K, &V], set[&V]) in Map; OR\nfunction rangeX : rel[&T0, &T1] (rel[&T0, &T1], set[&T2]) in Relation")
    ("rat" "function rat : Symbol () in ParseTree; OR\nfunction rat : Symbol () in Type")
    ("reach" "function reach : set[&T] (Graph[&T], set[&T]) in Graph")
    ("reachR" "function reachR : set[&T] (Graph[&T], set[&T], set[&T]) in Graph")
    ("reachX" "function reachX : set[&T] (Graph[&T], set[&T], set[&T]) in Graph")
    ("readBinaryValueFile" "function readBinaryValueFile : &T (type[&T], loc) in ValueIO; OR\nfunction readBinaryValueFile : value (loc) in ValueIO")
    ("readFile" "function readFile : list[str] (str) in IO; OR\nfunction readFile : str (loc) in IO")
    ("readFileBytes" "function readFileBytes : list[int] (loc) in IO")
    ("readFileLines" "function readFileLines : list[str] (loc) in IO")
    ("readTextValueFile" "function readTextValueFile : &T (type[&T], loc) in ValueIO; OR\nfunction readTextValueFile : value (loc) in ValueIO")
    ("readTextValueString" "function readTextValueString : &T (type[&T], str) in ValueIO; OR\nfunction readTextValueString : value (str) in ValueIO")
    ("readValueFile" "function readValueFile : value (loc) in ValueIO")
    ("real" "function real : Symbol () in ParseTree; OR\nfunction real : Symbol () in Type")
    ("reducer" "function reducer : &T (list[&T], &T (&T, &T), &T) in List; OR\nfunction reducer : &T (set[&T], &T (&T, &T), &T) in Set")
    ("reference" "function reference : Production (Symbol, str) in ParseTree")
    ("regular" "function regular : Production (Symbol) in ParseTree")
    ("reified" "function reified : Symbol (Symbol) in ParseTree; OR\nfunction reified : Symbol (Symbol) in Type")
    ("rel" "function rel : Symbol (list[Symbol]) in ParseTree; OR\nfunction rel : Symbol (list[Symbol]) in Type")
    ("remove" "function remove : list[&T] (list[&T], int) in List")
    ("replaceAll" "function replaceAll : str (str, str, str) in String")
    ("replaceFirst" "function replaceFirst : str (str, str, str) in String")
    ("replaceLast" "function replaceLast : str (str, str, str) in String")
    ("reverse" "function reverse : list[&T] (list[&T]) in List; OR\nfunction reverse : str (str) in String")
    ("rexpMatch" "function rexpMatch : bool (str, str) in String")
    ("right" "function right : Associativity () in ParseTree; OR\nfunction right : str (str, int) in String; OR\nfunction right : str (str, int, str) in String")
    ("rprint" "function rprint : void (value) in IO")
    ("rprintln" "function rprintln : void (value) in IO")
    ("sameType" "function sameType : bool (Symbol, Symbol) in ParseTree; OR\nfunction sameType : bool (Symbol, value) in ParseTree")
    ("seq" "function seq : Symbol (list[Symbol]) in ParseTree")
    ("set" "function set : Symbol (Symbol) in ParseTree; OR\nfunction set : Symbol (Symbol) in Type")
    ("setAnnotations" "function setAnnotations : &T<:node (&T<:node, map[str, value]) in Node")
    ("shortestPathPair" "function shortestPathPair : list[&T] (Graph[&T], &T, &T) in Graph")
    ("size" "function size : int (list[&T]) in List; OR\nfunction size : int (map[&K, &V]) in Map; OR\nfunction size : int (set[&T]) in Set; OR\nfunction size : int (str) in String")
    ("slice" "function slice : list[&T] (list[&T], int, int) in List")
    ("sort" "function sort : Symbol (str) in ParseTree; OR\nfunction sort : list[&T] (list[&T]) in List; OR\nfunction sort : list[&T] (list[&T], bool (&T, &T)) in List")
    ("split" "function split : list[str] (str, str) in String; OR\nfunction split : tuple[list[&T],list[&T]] (list[&T]) in List")
    ("splitDateTime" "function splitDateTime : tuple[datetime date,datetime time] (datetime) in DateTime")
    ("squeeze" "function squeeze : str (str, str) in String")
    ("start" "function start : Symbol (Symbol) in ParseTree")
    ("startsWith" "function startsWith : bool (str, str) in String")
    ("str" "function str : Symbol () in ParseTree; OR\nfunction str : Symbol () in Type")
    ("stringChar" "function stringChar : str (int) in String")
    ("stringChars" "function stringChars : str (list[int]) in String")
    ("substring" "function substring : str (str, int) in String; OR\nfunction substring : str (str, int, int) in String")
    ("subtype" "function subtype : bool (Symbol, Symbol) in ParseTree; OR\nfunction subtype : bool (Symbol, Symbol) in Type; OR\nfunction subtype : bool (Symbol, value) in ParseTree; OR\nfunction subtype : bool (Symbol, value) in Type; OR\nfunction subtype : bool (list[Symbol], list[Symbol]) in ParseTree; OR\nfunction subtype : bool (list[Symbol], list[Symbol]) in Type; OR\nfunction subtype : bool (type[&T], type[&U]) in ParseTree; OR\nfunction subtype : bool (type[&T], type[&U]) in Type")
    ("successors" "function successors : set[&T] (Graph[&T], &T) in Graph")
    ("sum" "function sum : num (list[num]) in List; OR\nfunction sum : num (set[num]) in Set")
    ("tag" "function tag : Attr (value) in ParseTree; OR\nfunction tag : Attr (value) in Type")
    ("tail" "function tail : list[&T] (list[&T]) in List; OR\nfunction tail : list[&T] (list[&T], int) in List")
    ("take" "function take : list[&T] (int, list[&T]) in List")
    ("takeOneFrom" "function takeOneFrom : tuple[&T,list[&T]] (list[&T]) in List; OR\nfunction takeOneFrom : tuple[&T,set[&T]] (set[&T]) in Set")
    ("takeWhile" "function takeWhile : list[&T] (list[&T], bool (&T)) in List")
    ("toInt" "function toInt : int (bool) in Boolean; OR\nfunction toInt : int (str) in String; OR\nfunction toInt : int (str, int) in String")
    ("toList" "function toList : list[&T] (set[&T]) in Set; OR\nfunction toList : list[tuple[&K,&V]] (map[&K, &V]) in Map")
    ("toLowerCase" "function toLowerCase : str (str) in String")
    ("toMap" "function toMap : map[&A, set[&B]] (list[tuple[&A,&B]]) in List; OR\nfunction toMap : map[&A, set[&B]] (rel[&A, &B]) in Set")
    ("toMapUnique" "function toMapUnique : map[&A, &B] (list[tuple[&A,&B]]) in List; OR\nfunction toMapUnique : map[&A, &B] (rel[&A, &B]) in Set")
    ("toReal" "function toReal : real (bool) in Boolean; OR\nfunction toReal : real (str) in String")
    ("toRel" "function toRel : rel[&K, &V] (map[&K, &V]) in Map; OR\nfunction toRel : rel[&K, &V] (map[&K, list[&V]]) in Map; OR\nfunction toRel : rel[&K, &V] (map[&K, set[&V]]) in Map; OR\nfunction toRel : rel[&T, &T] (list[&T]) in List")
    ("toSet" "function toSet : set[&T] (list[&T]) in List")
    ("toString" "function toString : str (bool) in Boolean; OR\nfunction toString : str (list[&T]) in List; OR\nfunction toString : str (map[&K, &V]) in Map; OR\nfunction toString : str (node) in Node; OR\nfunction toString : str (set[&T]) in Set; OR\nfunction toString : str (value) in ToString")
    ("toUpperCase" "function toUpperCase : str (str) in String")
    ("top" "function top : &T (list[&T]) in List; OR\nfunction top : set[&T] (Graph[&T]) in Graph")
    ("touch" "function touch : void (loc) in IO")
    ("treeAt" "function treeAt : TreeSearchResult[&T<:Tree] (type[&T<:Tree], loc, Tree) in ParseTree")
    ("treeFound" "function treeFound : TreeSearchResult[&T<:Tree] (&T) in ParseTree")
    ("treeNotFound" "function treeNotFound : TreeSearchResult[&T<:Tree] () in ParseTree")
    ("trim" "function trim : str (str) in String")
    ("tuple" "function tuple : Symbol (list[Symbol]) in ParseTree; OR\nfunction tuple : Symbol (list[Symbol]) in Type")
    ("typeCast" "function typeCast : &T (type[&T], value) in ParseTree; OR\nfunction typeCast : &T (type[&T], value) in Type")
    ("typeCastException" "function typeCastException : Exception (type[value], type[value]) in ParseTree; OR\nfunction typeCastException : Exception (type[value], type[value]) in Type")
    ("typeOf" "function typeOf : Symbol (value) in ParseTree; OR\nfunction typeOf : Symbol (value) in Type")
    ("unparse" "function unparse : str (Tree) in ParseTree")
    ("unzip" "function unzip : tuple[list[&T],list[&U],list[&V]] (list[tuple[&T,&U,&V]]) in List; OR\nfunction unzip : tuple[list[&T],list[&U]] (list[tuple[&T,&U]]) in List")
    ("upTill" "function upTill : list[int] (int) in List")
    ("value" "function value : Symbol () in ParseTree; OR\nfunction value : Symbol () in Type")
    ("var-func" "function var-func : Production (Symbol, str, list[tuple[Symbol typ,str label]], Symbol, str) in ParseTree; OR\nfunction var-func : Production (Symbol, str, list[tuple[Symbol typ,str label]], Symbol, str) in Type; OR\nfunction var-func : Symbol (Symbol, list[Symbol], Symbol) in ParseTree; OR\nfunction var-func : Symbol (Symbol, list[Symbol], Symbol) in Type")
    ("void" "function void : Symbol () in ParseTree; OR\nfunction void : Symbol () in Type")
    ("wrap" "function wrap : str (str, int) in String")
    ("writeBinaryValueFile" "function writeBinaryValueFile : void (loc, value) in ValueIO")
    ("writeFile" "function writeFile : void (loc, list[value]) in IO")
    ("writeTextValueFile" "function writeTextValueFile : void (loc, value) in ValueIO")
    ("zip" "function zip : list[tuple[&T first,&U second,&V third]] (list[&T], list[&U], list[&V]) in List; OR\nfunction zip : list[tuple[&T first,&U second]] (list[&T], list[&U]) in List")
) "public names in Rascal Prelude")

(provide 'rascal-mode-prelude)
